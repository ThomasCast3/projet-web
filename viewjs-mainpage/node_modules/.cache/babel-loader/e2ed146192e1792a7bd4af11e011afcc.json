{"ast":null,"code":"/*\n * Leaflet.curve v0.7.0 - a plugin for Leaflet mapping library. https://github.com/elfalem/Leaflet.curve\n * (c) elfalem 2015-2020\n */\n\n/*\n * note that SVG (x, y) corresponds to (long, lat)\n */\nL.Curve = L.Path.extend({\n  options: {},\n  initialize: function (path, options) {\n    L.setOptions(this, options);\n\n    this._setPath(path);\n  },\n  // Added to follow the naming convention of L.Polyline and other Leaflet component classes:\n  // (https://leafletjs.com/reference-1.6.0.html#polyline-setlatlngs)\n  setLatLngs: function (path) {\n    return this.setPath(path);\n  },\n  _updateBounds: function () {\n    var tolerance = this._clickTolerance();\n\n    var tolerancePoint = new L.Point(tolerance, tolerance); //_pxBounds is critical for canvas renderer, used to determine area that needs redrawing\n\n    this._pxBounds = new L.Bounds([this._rawPxBounds.min.subtract(tolerancePoint), this._rawPxBounds.max.add(tolerancePoint)]);\n  },\n  getPath: function () {\n    return this._coords;\n  },\n  setPath: function (path) {\n    this._setPath(path);\n\n    return this.redraw();\n  },\n  getBounds: function () {\n    return this._bounds;\n  },\n  _setPath: function (path) {\n    this._coords = path;\n    this._bounds = this._computeBounds();\n  },\n  _computeBounds: function () {\n    var bound = new L.LatLngBounds();\n    var lastPoint;\n    var lastCommand;\n    var coord;\n\n    for (var i = 0; i < this._coords.length; i++) {\n      coord = this._coords[i];\n\n      if (typeof coord == \"string\" || coord instanceof String) {\n        lastCommand = coord;\n      } else if (lastCommand == \"H\") {\n        bound.extend([lastPoint.lat, coord[0]]);\n        lastPoint = new L.latLng(lastPoint.lat, coord[0]);\n      } else if (lastCommand == \"V\") {\n        bound.extend([coord[0], lastPoint.lng]);\n        lastPoint = new L.latLng(coord[0], lastPoint.lng);\n      } else if (lastCommand == \"C\") {\n        var controlPoint1 = new L.latLng(coord[0], coord[1]);\n        coord = this._coords[++i];\n        var controlPoint2 = new L.latLng(coord[0], coord[1]);\n        coord = this._coords[++i];\n        var endPoint = new L.latLng(coord[0], coord[1]);\n        bound.extend(controlPoint1);\n        bound.extend(controlPoint2);\n        bound.extend(endPoint);\n        endPoint.controlPoint1 = controlPoint1;\n        endPoint.controlPoint2 = controlPoint2;\n        lastPoint = endPoint;\n      } else if (lastCommand == \"S\") {\n        controlPoint2 = new L.latLng(coord[0], coord[1]);\n        coord = this._coords[++i];\n        endPoint = new L.latLng(coord[0], coord[1]);\n        controlPoint1 = lastPoint;\n\n        if (lastPoint.controlPoint2) {\n          var diffLat = lastPoint.lat - lastPoint.controlPoint2.lat;\n          var diffLng = lastPoint.lng - lastPoint.controlPoint2.lng;\n          controlPoint1 = new L.latLng(lastPoint.lat + diffLat, lastPoint.lng + diffLng);\n        }\n\n        bound.extend(controlPoint1);\n        bound.extend(controlPoint2);\n        bound.extend(endPoint);\n        endPoint.controlPoint1 = controlPoint1;\n        endPoint.controlPoint2 = controlPoint2;\n        lastPoint = endPoint;\n      } else if (lastCommand == \"Q\") {\n        var controlPoint = new L.latLng(coord[0], coord[1]);\n        coord = this._coords[++i];\n        endPoint = new L.latLng(coord[0], coord[1]);\n        bound.extend(controlPoint);\n        bound.extend(endPoint);\n        endPoint.controlPoint = controlPoint;\n        lastPoint = endPoint;\n      } else if (lastCommand == \"T\") {\n        endPoint = new L.latLng(coord[0], coord[1]);\n        controlPoint = lastPoint;\n\n        if (lastPoint.controlPoint) {\n          diffLat = lastPoint.lat - lastPoint.controlPoint.lat;\n          diffLng = lastPoint.lng - lastPoint.controlPoint.lng;\n          controlPoint = new L.latLng(lastPoint.lat + diffLat, lastPoint.lng + diffLng);\n        }\n\n        bound.extend(controlPoint);\n        bound.extend(endPoint);\n        endPoint.controlPoint = controlPoint;\n        lastPoint = endPoint;\n      } else {\n        bound.extend(coord);\n        lastPoint = new L.latLng(coord[0], coord[1]);\n      }\n    }\n\n    return bound;\n  },\n  getCenter: function () {\n    return this._bounds.getCenter();\n  },\n  // _update() is invoked by Path._reset()\n  _update: function () {\n    if (!this._map) {\n      return;\n    } // TODO: consider implementing this._clipPoints(); and this._simplifyPoints(); to improve performance\n\n\n    this._updatePath();\n  },\n  _updatePath: function () {\n    // the following can be thought of as this._renderer.updateCurve() in both SVG/Canvas renderers\n    // similar to Canvas._updatePoly(), Canvas._updateCircle(), etc...\n    if (this._usingCanvas) {\n      this._updateCurveCanvas();\n    } else {\n      this._updateCurveSvg();\n    }\n  },\n  //_project() is invoked by Path._reset()\n  _project: function () {\n    var coord, lastCoord, curCommand, curPoint;\n    this._points = [];\n\n    for (var i = 0; i < this._coords.length; i++) {\n      coord = this._coords[i];\n\n      if (typeof coord == \"string\" || coord instanceof String) {\n        this._points.push(coord);\n\n        curCommand = coord;\n      } else {\n        switch (coord.length) {\n          case 2:\n            curPoint = this._map.latLngToLayerPoint(coord);\n            lastCoord = coord;\n            break;\n\n          case 1:\n            if (curCommand == \"H\") {\n              curPoint = this._map.latLngToLayerPoint([lastCoord[0], coord[0]]);\n              lastCoord = [lastCoord[0], coord[0]];\n            } else {\n              curPoint = this._map.latLngToLayerPoint([coord[0], lastCoord[1]]);\n              lastCoord = [coord[0], lastCoord[1]];\n            }\n\n            break;\n        }\n\n        this._points.push(curPoint);\n      }\n    }\n\n    if (this._bounds.isValid()) {\n      var northWestLayerPoint = this._map.latLngToLayerPoint(this._bounds.getNorthWest());\n\n      var southEastLayerPoint = this._map.latLngToLayerPoint(this._bounds.getSouthEast());\n\n      this._rawPxBounds = new L.Bounds(northWestLayerPoint, southEastLayerPoint);\n\n      this._updateBounds();\n    }\n  },\n  _curvePointsToPath: function (points) {\n    var point,\n        curCommand,\n        str = \"\";\n\n    for (var i = 0; i < points.length; i++) {\n      point = points[i];\n\n      if (typeof point == \"string\" || point instanceof String) {\n        curCommand = point;\n        str += curCommand;\n      } else {\n        switch (curCommand) {\n          case \"H\":\n            str += point.x + \" \";\n            break;\n\n          case \"V\":\n            str += point.y + \" \";\n            break;\n\n          default:\n            str += point.x + \",\" + point.y + \" \";\n            break;\n        }\n      }\n    }\n\n    return str || \"M0 0\";\n  },\n  beforeAdd: function (map) {\n    L.Path.prototype.beforeAdd.call(this, map);\n    this._usingCanvas = this._renderer instanceof L.Canvas;\n\n    if (this._usingCanvas) {\n      this._pathSvgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    }\n  },\n  onAdd: function (map) {\n    if (this._usingCanvas) {\n      // determine if dash array is set by user\n      this._canvasSetDashArray = !this.options.dashArray;\n    }\n\n    L.Path.prototype.onAdd.call(this, map); // calls _update()\n\n    if (this._usingCanvas) {\n      if (this.options.animate && typeof TWEEN === \"object\") {\n        this._normalizeCanvasAnimationOptions();\n\n        this._tweenedObject = {\n          offset: this._pathSvgElement.getTotalLength()\n        };\n        this._tween = new TWEEN.Tween(this._tweenedObject).to({\n          offset: 0\n        }, this.options.animate.duration) // difference of behavior with SVG, delay occurs on every iteration\n        .delay(this.options.animate.delay).repeat(this.options.animate.iterations - 1).onComplete(function (scope) {\n          return function () {\n            scope._canvasAnimating = false;\n          };\n        }(this)).start();\n        this._canvasAnimating = true;\n\n        this._animateCanvas();\n      } else {\n        this._canvasAnimating = false;\n      }\n    } else {\n      if (this.options.animate && this._path.animate) {\n        var length = this._svgSetDashArray();\n\n        this._path.animate([{\n          strokeDashoffset: length\n        }, {\n          strokeDashoffset: 0\n        }], this.options.animate);\n      }\n    }\n  },\n  // SVG specific logic\n  _updateCurveSvg: function () {\n    this._renderer._setPath(this, this._curvePointsToPath(this._points));\n\n    if (this.options.animate) {\n      this._svgSetDashArray();\n    }\n  },\n  _svgSetDashArray: function () {\n    var path = this._path;\n    var length = path.getTotalLength();\n\n    if (!this.options.dashArray) {\n      path.style.strokeDasharray = length + \" \" + length;\n    }\n\n    return length;\n  },\n  // Needed by the `Canvas` renderer for interactivity\n  _containsPoint: function (layerPoint) {\n    return this._bounds.contains(this._map.layerPointToLatLng(layerPoint));\n  },\n  // Canvas specific logic below here\n  _normalizeCanvasAnimationOptions: function () {\n    var opts = {\n      delay: 0,\n      duration: 0,\n      iterations: 1\n    };\n\n    if (typeof this.options.animate == \"number\") {\n      opts.duration = this.options.animate;\n    } else {\n      if (this.options.animate.duration) {\n        opts.duration = this.options.animate.duration;\n      }\n\n      if (this.options.animate.delay) {\n        opts.delay = this.options.animate.delay;\n      }\n\n      if (this.options.animate.iterations) {\n        opts.iterations = this.options.animate.iterations;\n      }\n    }\n\n    this.options.animate = opts;\n  },\n  _updateCurveCanvas: function () {\n    var pathString = this._curvePointsToPath(this._points);\n\n    this._pathSvgElement.setAttribute(\"d\", pathString);\n\n    if (this.options.animate && typeof TWEEN === \"object\" && this._canvasSetDashArray) {\n      this.options.dashArray = this._pathSvgElement.getTotalLength() + \"\";\n\n      this._renderer._updateDashArray(this);\n    }\n\n    this._curveFillStroke(new Path2D(pathString), this._renderer._ctx);\n  },\n  _animateCanvas: function () {\n    TWEEN.update(); // clear out area and re-render all layers\n\n    this._renderer._updatePaths();\n\n    if (this._canvasAnimating) {\n      this._animationFrameId = L.Util.requestAnimFrame(this._animateCanvas, this);\n    }\n  },\n  // similar to Canvas._fillStroke(ctx, layer)\n  _curveFillStroke: function (path2d, ctx) {\n    ctx.lineDashOffset = this._canvasAnimating ? this._tweenedObject.offset : 0.0;\n    var options = this.options;\n\n    if (options.fill) {\n      ctx.globalAlpha = options.fillOpacity;\n      ctx.fillStyle = options.fillColor || options.color;\n      ctx.fill(path2d, options.fillRule || \"evenodd\");\n    }\n\n    if (options.stroke && options.weight !== 0) {\n      if (ctx.setLineDash) {\n        ctx.setLineDash(this.options && this.options._dashArray || []);\n      }\n\n      ctx.globalAlpha = options.opacity;\n      ctx.lineWidth = options.weight;\n      ctx.strokeStyle = options.color;\n      ctx.lineCap = options.lineCap;\n      ctx.lineJoin = options.lineJoin;\n      ctx.stroke(path2d);\n    }\n  },\n  // path tracing logic below here\n  trace: function (t) {\n    // initially map is undefined, but then null if curve was added and removed\n    if (this._map === undefined || this._map === null) {\n      return [];\n    }\n\n    t = t.filter(function (element) {\n      return element >= 0 && element <= 1;\n    });\n    var point, curCommand, curStartPoint, curEndPoint;\n    var p1, p2, p3;\n    var samples = [];\n\n    for (var i = 0; i < this._points.length; i++) {\n      point = this._points[i];\n\n      if (typeof point == \"string\" || point instanceof String) {\n        curCommand = point;\n\n        if (curCommand == \"Z\") {\n          samples = samples.concat(this._linearTrace(t, curEndPoint, curStartPoint));\n        }\n      } else {\n        switch (curCommand) {\n          case \"M\":\n            curStartPoint = point;\n            curEndPoint = point;\n            break;\n\n          case \"L\":\n          case \"H\":\n          case \"V\":\n            samples = samples.concat(this._linearTrace(t, curEndPoint, point));\n            curEndPoint = point;\n            break;\n\n          case \"C\":\n            p1 = point;\n            p2 = this._points[++i];\n            p3 = this._points[++i];\n            samples = samples.concat(this._cubicTrace(t, curEndPoint, p1, p2, p3));\n            curEndPoint = p3;\n            break;\n\n          case \"S\":\n            p1 = this._reflectPoint(p2, curEndPoint);\n            p2 = point;\n            p3 = this._points[++i];\n            samples = samples.concat(this._cubicTrace(t, curEndPoint, p1, p2, p3));\n            curEndPoint = p3;\n            break;\n\n          case \"Q\":\n            p1 = point;\n            p2 = this._points[++i];\n            samples = samples.concat(this._quadraticTrace(t, curEndPoint, p1, p2));\n            curEndPoint = p2;\n            break;\n\n          case \"T\":\n            p1 = this._reflectPoint(p1, curEndPoint);\n            p2 = point;\n            samples = samples.concat(this._quadraticTrace(t, curEndPoint, p1, p2));\n            curEndPoint = p2;\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n\n    return samples;\n  },\n  _linearTrace: function (t, p0, p1) {\n    return t.map(interval => {\n      var x = this._singleLinearTrace(interval, p0.x, p1.x);\n\n      var y = this._singleLinearTrace(interval, p0.y, p1.y);\n\n      return this._map.layerPointToLatLng([x, y]);\n    });\n  },\n  _quadraticTrace: function (t, p0, p1, p2) {\n    return t.map(interval => {\n      var x = this._singleQuadraticTrace(interval, p0.x, p1.x, p2.x);\n\n      var y = this._singleQuadraticTrace(interval, p0.y, p1.y, p2.y);\n\n      return this._map.layerPointToLatLng([x, y]);\n    });\n  },\n  _cubicTrace: function (t, p0, p1, p2, p3) {\n    return t.map(interval => {\n      var x = this._singleCubicTrace(interval, p0.x, p1.x, p2.x, p3.x);\n\n      var y = this._singleCubicTrace(interval, p0.y, p1.y, p2.y, p3.y);\n\n      return this._map.layerPointToLatLng([x, y]);\n    });\n  },\n  _singleLinearTrace: function (t, p0, p1) {\n    return p0 + t * (p1 - p0);\n  },\n  _singleQuadraticTrace: function (t, p0, p1, p2) {\n    var oneMinusT = 1 - t;\n    return Math.pow(oneMinusT, 2) * p0 + 2 * oneMinusT * t * p1 + Math.pow(t, 2) * p2;\n  },\n  _singleCubicTrace: function (t, p0, p1, p2, p3) {\n    var oneMinusT = 1 - t;\n    return Math.pow(oneMinusT, 3) * p0 + 3 * Math.pow(oneMinusT, 2) * t * p1 + 3 * oneMinusT * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;\n  },\n  _reflectPoint: function (point, over) {\n    x = over.x + (over.x - point.x);\n    y = over.y + (over.y - point.y);\n    return L.point(x, y);\n  }\n});\n\nL.curve = function (path, options) {\n  return new L.Curve(path, options);\n};","map":{"version":3,"sources":["/Users/thomas/Documents/GitHub/projet-web/viewjs-mainpage/public/leaflet.curve.js"],"names":["L","Curve","Path","extend","options","initialize","path","setOptions","_setPath","setLatLngs","setPath","_updateBounds","tolerance","_clickTolerance","tolerancePoint","Point","_pxBounds","Bounds","_rawPxBounds","min","subtract","max","add","getPath","_coords","redraw","getBounds","_bounds","_computeBounds","bound","LatLngBounds","lastPoint","lastCommand","coord","i","length","String","lat","latLng","lng","controlPoint1","controlPoint2","endPoint","diffLat","diffLng","controlPoint","getCenter","_update","_map","_updatePath","_usingCanvas","_updateCurveCanvas","_updateCurveSvg","_project","lastCoord","curCommand","curPoint","_points","push","latLngToLayerPoint","isValid","northWestLayerPoint","getNorthWest","southEastLayerPoint","getSouthEast","_curvePointsToPath","points","point","str","x","y","beforeAdd","map","prototype","call","_renderer","Canvas","_pathSvgElement","document","createElementNS","onAdd","_canvasSetDashArray","dashArray","animate","TWEEN","_normalizeCanvasAnimationOptions","_tweenedObject","offset","getTotalLength","_tween","Tween","to","duration","delay","repeat","iterations","onComplete","scope","_canvasAnimating","start","_animateCanvas","_path","_svgSetDashArray","strokeDashoffset","style","strokeDasharray","_containsPoint","layerPoint","contains","layerPointToLatLng","opts","pathString","setAttribute","_updateDashArray","_curveFillStroke","Path2D","_ctx","update","_updatePaths","_animationFrameId","Util","requestAnimFrame","path2d","ctx","lineDashOffset","fill","globalAlpha","fillOpacity","fillStyle","fillColor","color","fillRule","stroke","weight","setLineDash","_dashArray","opacity","lineWidth","strokeStyle","lineCap","lineJoin","trace","t","undefined","filter","element","curStartPoint","curEndPoint","p1","p2","p3","samples","concat","_linearTrace","_cubicTrace","_reflectPoint","_quadraticTrace","p0","interval","_singleLinearTrace","_singleQuadraticTrace","_singleCubicTrace","oneMinusT","Math","pow","over","curve"],"mappings":"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","sourcesContent":["/*\n * Leaflet.curve v0.7.0 - a plugin for Leaflet mapping library. https://github.com/elfalem/Leaflet.curve\n * (c) elfalem 2015-2020\n */\n/*\n * note that SVG (x, y) corresponds to (long, lat)\n */\n\nL.Curve = L.Path.extend({\n    options: {},\n  \n    initialize: function (path, options) {\n      L.setOptions(this, options);\n      this._setPath(path);\n    },\n  \n    // Added to follow the naming convention of L.Polyline and other Leaflet component classes:\n    // (https://leafletjs.com/reference-1.6.0.html#polyline-setlatlngs)\n    setLatLngs: function (path) {\n      return this.setPath(path);\n    },\n  \n    _updateBounds: function () {\n      var tolerance = this._clickTolerance();\n      var tolerancePoint = new L.Point(tolerance, tolerance);\n  \n      //_pxBounds is critical for canvas renderer, used to determine area that needs redrawing\n      this._pxBounds = new L.Bounds([\n        this._rawPxBounds.min.subtract(tolerancePoint),\n        this._rawPxBounds.max.add(tolerancePoint)\n      ]);\n    },\n  \n    getPath: function () {\n      return this._coords;\n    },\n  \n    setPath: function (path) {\n      this._setPath(path);\n      return this.redraw();\n    },\n  \n    getBounds: function () {\n      return this._bounds;\n    },\n  \n    _setPath: function (path) {\n      this._coords = path;\n      this._bounds = this._computeBounds();\n    },\n  \n    _computeBounds: function () {\n      var bound = new L.LatLngBounds();\n      var lastPoint;\n      var lastCommand;\n      var coord;\n      for (var i = 0; i < this._coords.length; i++) {\n        coord = this._coords[i];\n        if (typeof coord == \"string\" || coord instanceof String) {\n          lastCommand = coord;\n        } else if (lastCommand == \"H\") {\n          bound.extend([lastPoint.lat, coord[0]]);\n          lastPoint = new L.latLng(lastPoint.lat, coord[0]);\n        } else if (lastCommand == \"V\") {\n          bound.extend([coord[0], lastPoint.lng]);\n          lastPoint = new L.latLng(coord[0], lastPoint.lng);\n        } else if (lastCommand == \"C\") {\n          var controlPoint1 = new L.latLng(coord[0], coord[1]);\n          coord = this._coords[++i];\n          var controlPoint2 = new L.latLng(coord[0], coord[1]);\n          coord = this._coords[++i];\n          var endPoint = new L.latLng(coord[0], coord[1]);\n  \n          bound.extend(controlPoint1);\n          bound.extend(controlPoint2);\n          bound.extend(endPoint);\n  \n          endPoint.controlPoint1 = controlPoint1;\n          endPoint.controlPoint2 = controlPoint2;\n          lastPoint = endPoint;\n        } else if (lastCommand == \"S\") {\n          controlPoint2 = new L.latLng(coord[0], coord[1]);\n          coord = this._coords[++i];\n          endPoint = new L.latLng(coord[0], coord[1]);\n  \n          controlPoint1 = lastPoint;\n          if (lastPoint.controlPoint2) {\n            var diffLat = lastPoint.lat - lastPoint.controlPoint2.lat;\n            var diffLng = lastPoint.lng - lastPoint.controlPoint2.lng;\n            controlPoint1 = new L.latLng(\n              lastPoint.lat + diffLat,\n              lastPoint.lng + diffLng\n            );\n          }\n  \n          bound.extend(controlPoint1);\n          bound.extend(controlPoint2);\n          bound.extend(endPoint);\n  \n          endPoint.controlPoint1 = controlPoint1;\n          endPoint.controlPoint2 = controlPoint2;\n          lastPoint = endPoint;\n        } else if (lastCommand == \"Q\") {\n          var controlPoint = new L.latLng(coord[0], coord[1]);\n          coord = this._coords[++i];\n          endPoint = new L.latLng(coord[0], coord[1]);\n  \n          bound.extend(controlPoint);\n          bound.extend(endPoint);\n  \n          endPoint.controlPoint = controlPoint;\n          lastPoint = endPoint;\n        } else if (lastCommand == \"T\") {\n          endPoint = new L.latLng(coord[0], coord[1]);\n  \n          controlPoint = lastPoint;\n          if (lastPoint.controlPoint) {\n            diffLat = lastPoint.lat - lastPoint.controlPoint.lat;\n            diffLng = lastPoint.lng - lastPoint.controlPoint.lng;\n            controlPoint = new L.latLng(\n              lastPoint.lat + diffLat,\n              lastPoint.lng + diffLng\n            );\n          }\n  \n          bound.extend(controlPoint);\n          bound.extend(endPoint);\n  \n          endPoint.controlPoint = controlPoint;\n          lastPoint = endPoint;\n        } else {\n          bound.extend(coord);\n          lastPoint = new L.latLng(coord[0], coord[1]);\n        }\n      }\n      return bound;\n    },\n  \n    getCenter: function () {\n      return this._bounds.getCenter();\n    },\n  \n    // _update() is invoked by Path._reset()\n    _update: function () {\n      if (!this._map) {\n        return;\n      }\n  \n      // TODO: consider implementing this._clipPoints(); and this._simplifyPoints(); to improve performance\n      this._updatePath();\n    },\n  \n    _updatePath: function () {\n      // the following can be thought of as this._renderer.updateCurve() in both SVG/Canvas renderers\n      // similar to Canvas._updatePoly(), Canvas._updateCircle(), etc...\n      if (this._usingCanvas) {\n        this._updateCurveCanvas();\n      } else {\n        this._updateCurveSvg();\n      }\n    },\n  \n    //_project() is invoked by Path._reset()\n    _project: function () {\n      var coord, lastCoord, curCommand, curPoint;\n  \n      this._points = [];\n  \n      for (var i = 0; i < this._coords.length; i++) {\n        coord = this._coords[i];\n        if (typeof coord == \"string\" || coord instanceof String) {\n          this._points.push(coord);\n          curCommand = coord;\n        } else {\n          switch (coord.length) {\n            case 2:\n              curPoint = this._map.latLngToLayerPoint(coord);\n              lastCoord = coord;\n              break;\n            case 1:\n              if (curCommand == \"H\") {\n                curPoint = this._map.latLngToLayerPoint([lastCoord[0], coord[0]]);\n                lastCoord = [lastCoord[0], coord[0]];\n              } else {\n                curPoint = this._map.latLngToLayerPoint([coord[0], lastCoord[1]]);\n                lastCoord = [coord[0], lastCoord[1]];\n              }\n              break;\n          }\n          this._points.push(curPoint);\n        }\n      }\n  \n      if (this._bounds.isValid()) {\n        var northWestLayerPoint = this._map.latLngToLayerPoint(\n          this._bounds.getNorthWest()\n        );\n        var southEastLayerPoint = this._map.latLngToLayerPoint(\n          this._bounds.getSouthEast()\n        );\n        this._rawPxBounds = new L.Bounds(\n          northWestLayerPoint,\n          southEastLayerPoint\n        );\n        this._updateBounds();\n      }\n    },\n  \n    _curvePointsToPath: function (points) {\n      var point,\n        curCommand,\n        str = \"\";\n      for (var i = 0; i < points.length; i++) {\n        point = points[i];\n        if (typeof point == \"string\" || point instanceof String) {\n          curCommand = point;\n          str += curCommand;\n        } else {\n          switch (curCommand) {\n            case \"H\":\n              str += point.x + \" \";\n              break;\n            case \"V\":\n              str += point.y + \" \";\n              break;\n            default:\n              str += point.x + \",\" + point.y + \" \";\n              break;\n          }\n        }\n      }\n      return str || \"M0 0\";\n    },\n  \n    beforeAdd: function (map) {\n      L.Path.prototype.beforeAdd.call(this, map);\n  \n      this._usingCanvas = this._renderer instanceof L.Canvas;\n  \n      if (this._usingCanvas) {\n        this._pathSvgElement = document.createElementNS(\n          \"http://www.w3.org/2000/svg\",\n          \"path\"\n        );\n      }\n    },\n  \n    onAdd: function (map) {\n      if (this._usingCanvas) {\n        // determine if dash array is set by user\n        this._canvasSetDashArray = !this.options.dashArray;\n      }\n  \n      L.Path.prototype.onAdd.call(this, map); // calls _update()\n  \n      if (this._usingCanvas) {\n        if (this.options.animate && typeof TWEEN === \"object\") {\n          this._normalizeCanvasAnimationOptions();\n  \n          this._tweenedObject = { offset: this._pathSvgElement.getTotalLength() };\n          this._tween = new TWEEN.Tween(this._tweenedObject)\n            .to({ offset: 0 }, this.options.animate.duration)\n            // difference of behavior with SVG, delay occurs on every iteration\n            .delay(this.options.animate.delay)\n            .repeat(this.options.animate.iterations - 1)\n            .onComplete(\n              (function (scope) {\n                return function () {\n                  scope._canvasAnimating = false;\n                };\n              })(this)\n            )\n            .start();\n  \n          this._canvasAnimating = true;\n          this._animateCanvas();\n        } else {\n          this._canvasAnimating = false;\n        }\n      } else {\n        if (this.options.animate && this._path.animate) {\n          var length = this._svgSetDashArray();\n  \n          this._path.animate(\n            [{ strokeDashoffset: length }, { strokeDashoffset: 0 }],\n            this.options.animate\n          );\n        }\n      }\n    },\n  \n    // SVG specific logic\n    _updateCurveSvg: function () {\n      this._renderer._setPath(this, this._curvePointsToPath(this._points));\n  \n      if (this.options.animate) {\n        this._svgSetDashArray();\n      }\n    },\n  \n    _svgSetDashArray: function () {\n      var path = this._path;\n      var length = path.getTotalLength();\n  \n      if (!this.options.dashArray) {\n        path.style.strokeDasharray = length + \" \" + length;\n      }\n      return length;\n    },\n  \n    // Needed by the `Canvas` renderer for interactivity\n    _containsPoint: function (layerPoint) {\n      return this._bounds.contains(this._map.layerPointToLatLng(layerPoint));\n    },\n  \n    // Canvas specific logic below here\n    _normalizeCanvasAnimationOptions: function () {\n      var opts = {\n        delay: 0,\n        duration: 0,\n        iterations: 1\n      };\n      if (typeof this.options.animate == \"number\") {\n        opts.duration = this.options.animate;\n      } else {\n        if (this.options.animate.duration) {\n          opts.duration = this.options.animate.duration;\n        }\n        if (this.options.animate.delay) {\n          opts.delay = this.options.animate.delay;\n        }\n        if (this.options.animate.iterations) {\n          opts.iterations = this.options.animate.iterations;\n        }\n      }\n  \n      this.options.animate = opts;\n    },\n  \n    _updateCurveCanvas: function () {\n      var pathString = this._curvePointsToPath(this._points);\n      this._pathSvgElement.setAttribute(\"d\", pathString);\n  \n      if (\n        this.options.animate &&\n        typeof TWEEN === \"object\" &&\n        this._canvasSetDashArray\n      ) {\n        this.options.dashArray = this._pathSvgElement.getTotalLength() + \"\";\n        this._renderer._updateDashArray(this);\n      }\n  \n      this._curveFillStroke(new Path2D(pathString), this._renderer._ctx);\n    },\n  \n    _animateCanvas: function () {\n      TWEEN.update();\n  \n      // clear out area and re-render all layers\n      this._renderer._updatePaths();\n  \n      if (this._canvasAnimating) {\n        this._animationFrameId = L.Util.requestAnimFrame(\n          this._animateCanvas,\n          this\n        );\n      }\n    },\n  \n    // similar to Canvas._fillStroke(ctx, layer)\n    _curveFillStroke: function (path2d, ctx) {\n      ctx.lineDashOffset = this._canvasAnimating\n        ? this._tweenedObject.offset\n        : 0.0;\n  \n      var options = this.options;\n  \n      if (options.fill) {\n        ctx.globalAlpha = options.fillOpacity;\n        ctx.fillStyle = options.fillColor || options.color;\n        ctx.fill(path2d, options.fillRule || \"evenodd\");\n      }\n  \n      if (options.stroke && options.weight !== 0) {\n        if (ctx.setLineDash) {\n          ctx.setLineDash((this.options && this.options._dashArray) || []);\n        }\n        ctx.globalAlpha = options.opacity;\n        ctx.lineWidth = options.weight;\n        ctx.strokeStyle = options.color;\n        ctx.lineCap = options.lineCap;\n        ctx.lineJoin = options.lineJoin;\n        ctx.stroke(path2d);\n      }\n    },\n  \n    // path tracing logic below here\n    trace: function (t) {\n      // initially map is undefined, but then null if curve was added and removed\n      if (this._map === undefined || this._map === null) {\n        return [];\n      }\n  \n      t = t.filter(function (element) {\n        return element >= 0 && element <= 1;\n      });\n  \n      var point, curCommand, curStartPoint, curEndPoint;\n      var p1, p2, p3;\n      var samples = [];\n      for (var i = 0; i < this._points.length; i++) {\n        point = this._points[i];\n        if (typeof point == \"string\" || point instanceof String) {\n          curCommand = point;\n  \n          if (curCommand == \"Z\") {\n            samples = samples.concat(\n              this._linearTrace(t, curEndPoint, curStartPoint)\n            );\n          }\n        } else {\n          switch (curCommand) {\n            case \"M\":\n              curStartPoint = point;\n              curEndPoint = point;\n              break;\n            case \"L\":\n            case \"H\":\n            case \"V\":\n              samples = samples.concat(this._linearTrace(t, curEndPoint, point));\n  \n              curEndPoint = point;\n              break;\n            case \"C\":\n              p1 = point;\n              p2 = this._points[++i];\n              p3 = this._points[++i];\n              samples = samples.concat(\n                this._cubicTrace(t, curEndPoint, p1, p2, p3)\n              );\n  \n              curEndPoint = p3;\n              break;\n            case \"S\":\n              p1 = this._reflectPoint(p2, curEndPoint);\n              p2 = point;\n              p3 = this._points[++i];\n              samples = samples.concat(\n                this._cubicTrace(t, curEndPoint, p1, p2, p3)\n              );\n  \n              curEndPoint = p3;\n              break;\n            case \"Q\":\n              p1 = point;\n              p2 = this._points[++i];\n              samples = samples.concat(\n                this._quadraticTrace(t, curEndPoint, p1, p2)\n              );\n  \n              curEndPoint = p2;\n              break;\n            case \"T\":\n              p1 = this._reflectPoint(p1, curEndPoint);\n              p2 = point;\n              samples = samples.concat(\n                this._quadraticTrace(t, curEndPoint, p1, p2)\n              );\n  \n              curEndPoint = p2;\n              break;\n            default:\n              break;\n          }\n        }\n      }\n      return samples;\n    },\n    _linearTrace: function (t, p0, p1) {\n      return t.map((interval) => {\n        var x = this._singleLinearTrace(interval, p0.x, p1.x);\n        var y = this._singleLinearTrace(interval, p0.y, p1.y);\n        return this._map.layerPointToLatLng([x, y]);\n      });\n    },\n    _quadraticTrace: function (t, p0, p1, p2) {\n      return t.map((interval) => {\n        var x = this._singleQuadraticTrace(interval, p0.x, p1.x, p2.x);\n        var y = this._singleQuadraticTrace(interval, p0.y, p1.y, p2.y);\n        return this._map.layerPointToLatLng([x, y]);\n      });\n    },\n    _cubicTrace: function (t, p0, p1, p2, p3) {\n      return t.map((interval) => {\n        var x = this._singleCubicTrace(interval, p0.x, p1.x, p2.x, p3.x);\n        var y = this._singleCubicTrace(interval, p0.y, p1.y, p2.y, p3.y);\n        return this._map.layerPointToLatLng([x, y]);\n      });\n    },\n    _singleLinearTrace: function (t, p0, p1) {\n      return p0 + t * (p1 - p0);\n    },\n    _singleQuadraticTrace: function (t, p0, p1, p2) {\n      var oneMinusT = 1 - t;\n      return (\n        Math.pow(oneMinusT, 2) * p0 + 2 * oneMinusT * t * p1 + Math.pow(t, 2) * p2\n      );\n    },\n    _singleCubicTrace: function (t, p0, p1, p2, p3) {\n      var oneMinusT = 1 - t;\n      return (\n        Math.pow(oneMinusT, 3) * p0 +\n        3 * Math.pow(oneMinusT, 2) * t * p1 +\n        3 * oneMinusT * Math.pow(t, 2) * p2 +\n        Math.pow(t, 3) * p3\n      );\n    },\n    _reflectPoint: function (point, over) {\n      x = over.x + (over.x - point.x);\n      y = over.y + (over.y - point.y);\n      return L.point(x, y);\n    }\n  });\n  \n  L.curve = function (path, options) {\n    return new L.Curve(path, options);\n  };\n  "]},"metadata":{},"sourceType":"script"}